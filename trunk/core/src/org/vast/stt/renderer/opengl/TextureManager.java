/***************************************************************
 (c) Copyright 2005, University of Alabama in Huntsville (UAH)
 ALL RIGHTS RESERVED

 This software is the property of UAH.
 It cannot be duplicated, used, or distributed without the
 express written consent of UAH.

 This software developed by the Vis Analysis Systems Technology
 (VAST) within the Earth System Science Lab under the direction
 of Mike Botts (mike.botts@atmos.uah.edu)
 ***************************************************************/

package org.vast.stt.renderer.opengl;

import java.nio.ByteBuffer;

import javax.media.opengl.GL;
import javax.media.opengl.glu.GLU;

import org.vast.stt.style.DataStyler;
import org.vast.stt.style.RasterPixelGraphic;
import org.vast.stt.style.RasterTileGraphic;
import org.vast.stt.style.TextureMappingStyler;


/**
 * <p><b>Title:</b><br/>
 * Texture Generator
 * </p>
 *
 * <p><b>Description:</b><br/>
 * Generated POT or NPOT textures according to OpenGL hardware 
 * capabilities. POT textures can be generated by resampling or
 * padding with 100% transparent white pixels, in which case
 * texture coordinates are automatically adjusted.
 * </p>
 *
 * <p>Copyright (c) 2005</p>
 * @author Alexandre Robin
 * @date Apr 13, 2006
 * @version 1.0
 */
public class TextureManager
{
    protected DataStyler styler;
    protected GL gl;
    protected GLU glu;
    
    
    public TextureManager(GL gl, GLU glu)
    {
        this.gl = gl;
        this.glu = glu;
    }
    
    
    /**
     * Retrieves stored textureID or create a new one along
     * with the corresponding texture in OpenGL memory.
     * @param tex
     * @return
     */
    public void bindTexture(RasterTileGraphic tex)
    {
        int textureID = 0;
                
        // create OpenGLInfo object if needed
        OpenGLInfo info;
        if (tex.hasRendererInfo)
            info = (OpenGLInfo)tex.rendererInfo;
        else
        {
            info = new OpenGLInfo();
            tex.rendererInfo = info;
        }
        
        // delete old texture if it has been updated, otherwise just get ID
        if (tex.updated && info.objectID != -1)
            gl.glDeleteTextures(1, new int[] {info.objectID}, 0);
        else
            textureID = info.objectID;
        
        // create texture if no ID was found
        if (textureID <= 0)
        {
            fillRGBAData(tex);
            
            if (tex.hasRasterData)
            {
                int[] id = new int[1];
                gl.glGenTextures(1, id, 0);
                textureID = id[0];
                gl.glBindTexture(OpenGLCaps.TEXTURE_2D_TARGET, textureID);
                gl.glTexImage2D(OpenGLCaps.TEXTURE_2D_TARGET, 0, GL.GL_RGBA, tex.width, tex.height,
                                0, GL.GL_RGBA, GL.GL_UNSIGNED_BYTE, tex.rasterData);
                
                // save the texture ID
                info.objectID = textureID;
                tex.hasRendererInfo = true;
                tex.updated = false;
            }                    
        }
        else
        {
            // just bind previously loaded texture
            gl.glBindTexture(OpenGLCaps.TEXTURE_2D_TARGET, textureID);
        }
    }
    
    
    protected void fillRGBData(RasterTileGraphic texture)
    {
    }
    
    
    protected void fillRGBAData(RasterTileGraphic tex)
    {
        int width = tex.width;
        int height = tex.height;
        byte[] buffer = new byte[width*height*4];
        int index = 0;
        
        if (styler instanceof TextureMappingStyler)
        {
            for (int j=0; j<height; j++)
            {
                for (int i=0; i<width; i++)
                {
                    RasterPixelGraphic pixel = ((TextureMappingStyler)styler).getPixel(i, j);
                    buffer[index] = (byte)(255.0 * pixel.r);
                    index++;
                    buffer[index] = (byte)(255.0 * pixel.g);
                    index++;
                    buffer[index] = (byte)(255.0 * pixel.b);
                    index++;
                    buffer[index] = (byte)(255.0 * pixel.a);
                    index++;
                }
            }
        }
        
        tex.rasterData = ByteBuffer.wrap(buffer);
        tex.hasRasterData = true;
        tex.hasColorMapData = false;
    }
    
    
    protected void fillTestRGBAData(RasterTileGraphic tex)
    {
        
    }
    
    
    public void setStyler(DataStyler styler)
    {
        this.styler = styler;
    }
}
