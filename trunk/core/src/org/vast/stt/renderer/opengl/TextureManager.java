/***************************************************************
 (c) Copyright 2005, University of Alabama in Huntsville (UAH)
 ALL RIGHTS RESERVED

 This software is the property of UAH.
 It cannot be duplicated, used, or distributed without the
 express written consent of UAH.

 This software developed by the Vis Analysis Systems Technology
 (VAST) within the Earth System Science Lab under the direction
 of Mike Botts (mike.botts@atmos.uah.edu)
 ***************************************************************/

package org.vast.stt.renderer.opengl;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.List;

import javax.media.opengl.GL;
import javax.media.opengl.glu.GLU;
import org.vast.ows.sld.Symbolizer;
import org.vast.stt.style.DataStyler;
import org.vast.stt.style.GridPatchGraphic;
import org.vast.stt.style.RasterPixelGraphic;
import org.vast.stt.style.RasterTileGraphic;
import org.vast.stt.style.TextureStyler;
import org.vast.util.MessageSystem;


/**
 * <p><b>Title:</b><br/>
 * Texture Manager
 * </p>
 *
 * <p><b>Description:</b><br/>
 * Generate POT or NPOT textures according to OpenGL hardware 
 * capabilities. POT textures are generated by padding with 100%
 * transparent white pixels, in which case texture coordinates
 * are automatically adjusted.
 * </p>
 *
 * <p>Copyright (c) 2005</p>
 * @author Alexandre Robin
 * @date Apr 13, 2006
 * @version 1.0
 */
public class TextureManager
{
    protected static Hashtable<Symbolizer, GLTextureTable> symTextureTables
               = new Hashtable<Symbolizer, GLTextureTable>();
    protected GL gl;
    protected GLU glu;
    protected boolean forceNoExt = false;
    protected boolean npotSupported;
    protected boolean normalizationRequired;
    protected int texCount = 0;
    protected int maxSize = 512;
    protected int maxWastedPixels = 100;
    
    
    class GLTexture
    {
        protected int id = -1;
        protected boolean needsUpdate = true;
        protected int widthPadding;
        protected int heightPadding;
        protected List<GLTexture> tiles;
    }
    
    
    class GLTextureTiles
    {
        
    }
    
    
    class GLTextureTable extends Hashtable<Object, GLTexture>
    {
        private final static long serialVersionUID = 0;
    }
    
    
    public TextureManager(GL gl, GLU glu)
    {
        this.gl = gl;
        this.glu = glu;
        
        // find out which texture 2D target to use
        String glExtensions = gl.glGetString(GL.GL_EXTENSIONS);
        if (!forceNoExt && glu.gluCheckExtension("GL_ARB_texture_rectangle", glExtensions) ||
            glu.gluCheckExtension("GL_EXT_texture_rectangle", glExtensions))
        {
            OpenGLCaps.TEXTURE_2D_TARGET = GL.GL_TEXTURE_RECTANGLE_EXT;
            MessageSystem.display("--> NPOT textures supported <--", false);
            npotSupported = true;
            normalizationRequired = false;
        }
        else
        {
            OpenGLCaps.TEXTURE_2D_TARGET = GL.GL_TEXTURE_2D;
            MessageSystem.display("--> NPOT textures NOT supported <--", false);
            MessageSystem.display("--> Textures will be padded with transparent pixels or resampled <--", false);
            npotSupported = false;
            normalizationRequired = true;
        }
        
        // enable right texture target
        gl.glEnable(OpenGLCaps.TEXTURE_2D_TARGET);
        
        // Display max texture size
        int[] size = new int[1];
        gl.glGetIntegerv(GL.GL_MAX_TEXTURE_SIZE, size, 0);
        MessageSystem.display("--> Maximum texture size is " + size[0] + " <--", false);
        //maxSize = size[0];
    }
    
    
    /**
     * Retrieves stored textureID or create a new one along
     * with the corresponding texture in OpenGL memory.
     * @param styler
     * @param tex
     * @param force
     * @return
     */
    public GLTexture getTexture(TextureStyler styler, RasterTileGraphic tex, boolean force)
    {
        GLTexture texInfo = null;
        Symbolizer sym = styler.getSymbolizer();
        
        synchronized (symTextureTables)
        {
            // try to find table for this symbolizer
            GLTextureTable textureTable = symTextureTables.get(sym);
            
            // create if it doesn't exist
            if (textureTable == null)
            {
                textureTable = new GLTextureTable();
                symTextureTables.put(sym, textureTable);
            }
                
            // try to find texture for this tile
            texInfo = textureTable.get(tex.block);
            
            // create if it doesn't exist
            if (texInfo == null)
            {
                texInfo = new GLTexture();
                textureTable.put(tex.block, texInfo);
            }            
            
            // create new texture if it needs update
            if (texInfo.needsUpdate || force)
            {
                texInfo.needsUpdate = false;
                createTexture(styler, tex, texInfo);
            }
            
            return texInfo;
        }
    }
    
    
    /**
     * Bind texture
     * @param tex
     * @return
     */
    public void useTexture(GLTexture texInfo, RasterTileGraphic tex)
    {
        // otherwise just bind existing one
        if (texInfo.id > 0)
        {
            gl.glBindTexture(OpenGLCaps.TEXTURE_2D_TARGET, texInfo.id);
            //System.err.println("Tex #" + texInfo.id + " used");
        }
        
        // transfer padding info to RasterTileGraphic
        tex.heightPadding = texInfo.heightPadding;
        tex.widthPadding = texInfo.widthPadding;
    }
    
    
    /**
     * Creates a new texture by transfering data from styler to GL memory
     * @param styler
     * @param tex
     * @param texInfo
     */
    protected void createTexture(TextureStyler styler, RasterTileGraphic tex, GLTexture texInfo)
    {
        // fetch texture data from styler
        fillTexData(styler, tex, texInfo);
        
        // if texture was successfully constructed, bind it with GL
        if (tex.hasRasterData)
        {
            // create new texture name and bind it
            int[] id = new int[1];
            gl.glGenTextures(1, id, 0); 
            gl.glBindTexture(OpenGLCaps.TEXTURE_2D_TARGET, id[0]);
            
            // set texture parameters
            //  TODO:  Allow user to select between Linear (smoothed) and nearest-neighbor interp
            gl.glTexParameteri(OpenGLCaps.TEXTURE_2D_TARGET, GL.GL_TEXTURE_MIN_FILTER, GL.GL_LINEAR);//GL.GL_NEAREST);
            gl.glTexParameteri(OpenGLCaps.TEXTURE_2D_TARGET, GL.GL_TEXTURE_MAG_FILTER, GL.GL_LINEAR);//GL.GL_NEAREST);
//            gl.glTexParameteri(OpenGLCaps.TEXTURE_2D_TARGET, GL.GL_TEXTURE_MIN_FILTER, GL.GL_NEAREST);//GL.GL_NEAREST);
//            gl.glTexParameteri(OpenGLCaps.TEXTURE_2D_TARGET, GL.GL_TEXTURE_MAG_FILTER, GL.GL_NEAREST);//GL.GL_NEAREST);
            gl.glTexParameterf(OpenGLCaps.TEXTURE_2D_TARGET, GL.GL_TEXTURE_WRAP_S, GL.GL_CLAMP_TO_EDGE);
            gl.glTexParameterf(OpenGLCaps.TEXTURE_2D_TARGET, GL.GL_TEXTURE_WRAP_T, GL.GL_CLAMP_TO_EDGE);
            
            // figure out image format
            int format = 0;
            switch (tex.bands)
            {
                case 1:
                    format = GL.GL_LUMINANCE;
                    break;
                    
                case 2:
                    format = GL.GL_LUMINANCE_ALPHA;
                    break;
                
                case 3:
                    format = GL.GL_RGB;
                    break;
                    
                case 4:    
                    format = GL.GL_RGBA;
                    break;                
            }
            
            // create texture in GL memory
            gl.glPixelStorei(GL.GL_UNPACK_ALIGNMENT, 1);
            gl.glTexImage2D(OpenGLCaps.TEXTURE_2D_TARGET, 0, tex.bands,
                    tex.width + texInfo.widthPadding, tex.height + texInfo.heightPadding,
                    0, format, GL.GL_UNSIGNED_BYTE, tex.rasterData);
            
            // erase temp buffer
            tex.rasterData = null;
            
            // set new id and reset needsUpdate flag
            int oldID = texInfo.id;
            texInfo.id = id[0];
            
            // delete previous texture if needed
            if (oldID > 0)
            {
                gl.glDeleteTextures(1, new int[] {oldID}, 0);
                //System.err.println("Tex #" + oldID + " deleted");
            }
            
            //texCount++;
            //System.out.println(texCount);
            
            //System.err.println("Tex #" + texInfo.id + " created");
        }
    }
    
    
    /**
     * Clears all textures used by this symbolizer
     * @param sym
     */
    public void clearTextures(DataStyler styler)
    {
        synchronized (symTextureTables)
        {
            Symbolizer sym = styler.getSymbolizer();
            GLTextureTable textureTable = symTextureTables.get(sym);
            
            if (textureTable != null)
            {
                Enumeration<GLTexture> textureEnum = textureTable.elements();
                while (textureEnum.hasMoreElements())
                {
                    GLTexture texInfo = textureEnum.nextElement();
                    if (texInfo.id > 0)
                    {
                        // System.out.println("Tex# " + texInfo.id + " " + (gl.glIsTexture(texInfo.id) ? "on" : "off"));
                        gl.glDeleteTextures(1, new int[] {texInfo.id}, 0);
                        // System.out.println("Tex# " + texInfo.id + " " + (gl.glIsTexture(texInfo.id) ? "on" : "off"));
                        //texCount--;
                    }
                    
                    textureTable.remove(texInfo);
                }
                
                symTextureTables.remove(sym);
            }
        }
    }
    
    
    /**
     * Clears texture used by this symbolizer and
     * associatd with the given objects
     * @param sym
     * @param obj
     */
    public void clearTextures(DataStyler styler, Object[] objects)
    {
        synchronized (symTextureTables)
        {
            Symbolizer sym = styler.getSymbolizer();
            GLTextureTable textureTable = symTextureTables.get(sym);
            
            if (textureTable != null)
            {
                for (int i=0; i<objects.length; i++)
                {
                    GLTexture texInfo = textureTable.get(objects[i]);
                    if (texInfo != null)
                    {
                        textureTable.remove(texInfo);                        
                        if (texInfo.id > 0)
                        {
                            //System.out.println("Tex# " + texInfo.id + " " + (gl.glIsTexture(texInfo.id) ? "on" : "off"));
                            gl.glDeleteTextures(1, new int[] {texInfo.id}, 0);
                            //System.out.println("Tex# " + texInfo.id + " " + (gl.glIsTexture(texInfo.id) ? "on" : "off"));
                            //texCount--;
                        }
                    }
                    
                    
                }
            }
            
            //System.out.println(texCount);
        }
    }
    
    
    /**
     * Create a texture based on data passed by styler
     * @param styler
     * @param tex
     * @param texInfo
     */
    protected void fillTexData(TextureStyler styler, RasterTileGraphic tex, GLTexture texInfo)
    {
        int paddedWidth = tex.width;
        int paddedHeight = tex.height;
        int initialWidth = tex.width;
        int initialHeight = tex.height;
                
        // handle case of padding for npot
        if (!npotSupported)
        {
            // determine closest power of 2
            paddedWidth = closestHigherPowerOfTwo(initialWidth);
            paddedHeight = closestHigherPowerOfTwo(initialHeight);          
            
            // display warning message if padding is needed
            if (paddedWidth != initialWidth || paddedHeight != initialHeight)
            {
                MessageSystem.display("Texture will be padded to have a power of two size.\n" +
                                      "    initial size: " + initialWidth + " x " + initialHeight + "\n" +
                                      "     padded size: " + paddedWidth + " x " + paddedHeight, false);
                
                texInfo.widthPadding = paddedWidth - initialWidth;
                texInfo.heightPadding = paddedHeight - initialHeight;
            }
        }
        
        // create byte buffer of the right size
        ByteBuffer buffer = ByteBuffer.allocateDirect(paddedWidth*paddedHeight*tex.bands);
        //System.err.println("Creating " + paddedWidth + " x " + paddedHeight + " Texture with " + tex.bands + " bands");
        int index = 0;
        
        for (int j=0; j<initialHeight; j++)
        {
            for (int i=0; i<initialWidth; i++)
            {
                RasterPixelGraphic pixel = styler.getPixel(i + tex.xPos, j + tex.yPos);
                buffer.put(index, (byte)pixel.r);
                index++;
                
                // only if RGB
                if (tex.bands > 2)
                {
                    buffer.put(index, (byte)pixel.g);
                    index++;
                    buffer.put(index, (byte)pixel.b);
                    index++;
                }
                
                // only if RGBA
                if (tex.bands == 2 || tex.bands == 4)
                {
                    buffer.put(index, (byte)pixel.a);
                    index++;
                }
                
                //System.out.println(i + "," + j + ": " + pixel.r + "," + pixel.g + "," + pixel.b);
            }
            
            // skip padding bytes
            index += texInfo.widthPadding*tex.bands;
        }
        
        tex.rasterData = buffer;
        tex.hasRasterData = true;
    }
    
    
    /**
     * Split a Grid in several tiles with dimensions
     * equal to full powers of two
     * @param tex
     * @return
     */
    protected List<GridPatchGraphic> splitGrid(GridPatchGraphic tex, List<RasterTileGraphic> rasterTiles)
    {
        return null;
    }
    
    
    /**
     * Split a Raster in several tiles with dimensions
     * equal to full powers of two
     * @param tex
     * @return
     */
    public List<RasterTileGraphic> splitTexture(RasterTileGraphic tex)
    {
        List<Integer> widthList =  getPower2SizeList(tex.width);
        List<Integer> heightList =  getPower2SizeList(tex.height);
        int xSegs = widthList.size();
        int ySegs = heightList.size();
        
        List<RasterTileGraphic> tileList = new ArrayList<RasterTileGraphic>(xSegs*ySegs);
        int dX = 0;
        int dY = 0;
        
        for (int i=0; i<xSegs; i++)
        {
            int width = widthList.get(i);
            int widthPadding = 0;
            if (i == xSegs-1)
                widthPadding = width - (tex.width - dX);
                
            dY = 0;
            for (int j=0; j<ySegs; j++)
            {
                RasterTileGraphic nextTile = new RasterTileGraphic();
                int height = heightList.get(j);
                int heightPadding = 0;
                if (j == ySegs-1)
                    heightPadding = height - (tex.height - dY);
                
                nextTile.width = width;
                nextTile.height = height;
                nextTile.xPos = dX;
                nextTile.yPos = dY;
                nextTile.widthPadding = widthPadding;
                nextTile.heightPadding = heightPadding;
                dY += height;
                
                tileList.add(nextTile);
            }

            dX += width;
        }
        
        for (int i=0; i<tileList.size(); i++)
        {
            RasterTileGraphic t = tileList.get(i);
            //GridPatchGraphic g = gridList.get(i);
            
            System.out.println("Tile: " + t.width + "x" + t.height + " @ " +
                                          t.xPos + "," + t.yPos + " pad " +
                                          t.widthPadding + "x" + t.heightPadding);
        }
        
        return tileList;
    }
    
    
    /**
     * Breaks done the argument into a list of power of two values
     * @param size
     * @return
     */
    protected List<Integer> getPower2SizeList(int size)
    {
        List<Integer> sizeList = new ArrayList<Integer>();
        int remainSize = size;
        boolean done = false;

        do
        {
            int nextSize = closestHigherPowerOfTwo(remainSize);
            int wastedPixels = nextSize - remainSize;
            
            if (nextSize <= maxSize && wastedPixels <= maxWastedPixels)
            {
                done = true;
            }
            else
            {
                nextSize = closestLowerPowerOfTwo(remainSize);
                remainSize = remainSize - nextSize;
            }

            sizeList.add(nextSize);
        }
        while(!done);

        return sizeList;
    }
    
    
    /**
     * Calculate closest power of two value lower than argument
     * @param val
     * @return
     */
    protected int closestLowerPowerOfTwo(int val)
    {
        int power = (int)Math.floor(log2(val));
        int pow2 = (int)Math.pow(2, power);
        
        if (pow2 > maxSize)
            return maxSize;
        else
            return pow2; 
    }


    /**
     * Calculate closest power of two value higher than argument
     * TODO closestHigherPowerOfTwo method description
     * @param val
     * @return
     */
    protected int closestHigherPowerOfTwo(int val)
    {
        int power = (int)Math.ceil(log2(val));
        return (int)Math.pow(2, power);
    }


    /**
     * Calculate log base 2 of the argument
     * @param val
     * @return
     */
    protected double log2(double val)
    {
        return Math.log(val)/Math.log(2);
    }


    public boolean isNpotSupported()
    {
        return npotSupported;
    }


    public boolean isNormalizationRequired()
    {
        return normalizationRequired;
    }
}